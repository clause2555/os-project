/* interrupts.S */
.section .idt, "aw", @progbits
.align 8

.global interrupt_stub
.type interrupt_stub, @function
interrupt_stub:
    # Pop the interrupt number pushed by the stub into %eax
    popl %eax              # %eax now contains the interrupt number

    pusha                  # Save all general-purpose registers
    push %ds               # Save data segment registers
    push %es
    push %fs
    push %gs

    # Set DS, ES, FS, GS to kernel data segment (0x10)
    movw $0x10, %ax
    movw %ax, %ds
    movw %ax, %es
    movw %ax, %fs
    movw %ax, %gs

    # Push the interrupt number onto the stack to pass it as an argument
    pushl %eax

    # Call the C++ interrupt handler
    call interrupt_handler_c

    # Clean up the stack (remove the argument)
    add $4, %esp

    pop %gs                # Restore segment registers
    pop %fs
    pop %es
    pop %ds
    popa                   # Restore general-purpose registers

    # Send End of Interrupt (EOI) to PIC if necessary
    cmp $32, %eax          # Check if interrupt number >= 32 (IRQ0 and above)
    jl no_eoi_needed
    movb $0x20, %al
    outb %al, $0x20        # Send EOI to Master PIC
    cmp $40, %eax          # Check if interrupt number >= 40 (IRQ8 and above)
    jl no_eoi_needed
    outb %al, $0xA0        # Send EOI to Slave PIC
no_eoi_needed:

    iret                   # Return from interrupt

.global isr0_stub
.type isr0_stub, @function
isr0_stub:
    pushl $0               # Push interrupt number (0)
    jmp interrupt_stub

.global isr1_stub
.type isr1_stub, @function
isr1_stub:
    pushl $1               # Push interrupt number (1)
    jmp interrupt_stub

.global isr14_stub
.type isr14_stub, @function
isr14_stub:
    # Error code is already on the stack (pushed by CPU)
    pushl $14              # Push interrupt number (14)
    jmp interrupt_stub_error

.global irq0_stub
.type irq0_stub, @function
irq0_stub:
    pushl $32              # IRQ0 mapped to interrupt 32
    jmp interrupt_stub

# Common stub for interrupts with error codes
.global interrupt_stub_error
.type interrupt_stub_error, @function
interrupt_stub_error:
    popl %eax              # %eax now contains the interrupt number
    pusha                  # Save all general-purpose registers
    push %ds               # Save data segment registers
    push %es
    push %fs
    push %gs

    # Set DS, ES, FS, GS to kernel data segment (0x10)
    movw $0x10, %ax
    movw %ax, %ds
    movw %ax, %es
    movw %ax, %fs
    movw %ax, %gs

    # Push error code and interrupt number onto the stack
    movl 8(%esp), %edx     # Get error code (was pushed by CPU)
    pushl %edx             # Push error code
    pushl %eax             # Push interrupt number

    # Call the C++ interrupt handler with error code
    call interrupt_handler_c_with_error_code

    # Clean up the stack (remove error code and interrupt number)
    add $8, %esp

    pop %gs                # Restore segment registers
    pop %fs
    pop %es
    pop %ds
    popa                   # Restore general-purpose registers

    # Send End of Interrupt (EOI) to PIC if necessary
    cmp $32, %eax          # Check if interrupt number >= 32 (IRQ0 and above)
    jl no_eoi_needed_error
    movb $0x20, %al
    outb %al, $0x20        # Send EOI to Master PIC
    cmp $40, %eax          # Check if interrupt number >= 40 (IRQ8 and above)
    jl no_eoi_needed_error
    outb %al, $0xA0        # Send EOI to Slave PIC
no_eoi_needed_error:

    add $4, %esp           # Remove the error code pushed by CPU
    iret                   # Return from interrupt

